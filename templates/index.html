<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Huiber</title>
    <link rel="icon" type="image/png" href="/static/logo.png" />
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
    <style>
      /* --- Стили CSS --- */
      body {
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
          margin: 0;
          background: url('/static/background.png') no-repeat center center fixed;
          background-size: cover;
          display: flex;
          flex-direction: column;
          align-items: center;
          color: #333; /* Базовый цвет текста */
      }
      h1 {
          font-size: 28px; /* Немного крупнее */
          color: #4a148c; /* Фиолетовый */
          margin: 25px 0;
          display: flex;
          align-items: center;
          justify-content: center; /* Центрируем заголовок */
          width: 100%;
          position: relative; /* Для позиционирования кнопки профиля */
          text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
      }
      h1 button#profile-btn {
           font-size: 16px; /* Размер кнопки профиля */
           margin-left: 15px;
           padding: 8px 12px;
           background-color: #e1bee7; /* Светло-фиолетовый фон */
           color: #4a148c;
           border: none;
           border-radius: 20px; /* Сильно скругленные углы */
           cursor: pointer;
           transition: background-color 0.2s ease;
           box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      }
      h1 button#profile-btn:hover {
          background-color: #ce93d8; /* Темнее при наведении */
      }

      #chat-container, #username-form, #profile-modal, #users-list, #call-modal, #call-window {
          width: 100%;
          max-width: 650px; /* Немного шире */
          background: rgba(255, 255, 255, 0.92); /* Чуть менее прозрачный фон */
          border: 1px solid #ce93d8; /* Фиолетовая граница */
          border-radius: 18px; /* Более скругленные углы */
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); /* Усиленная тень */
          margin-bottom: 20px; /* Больше отступ снизу */
          display: flex; /* Используем flex для контейнеров */
          flex-direction: column; /* Элементы внутри идут столбиком */
      }

      /* Стили для модальных окон (переопределение) */
      #username-form, #profile-modal, #call-modal, #call-window {
          padding: 35px;
          text-align: center;
          position: fixed; /* Остаются модальными */
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          display: none; /* Скрыты по умолчанию */
          z-index: 1000;
          width: 90%;
          max-width: 450px; /* Макс ширина модалок */
           flex-direction: column; /* Элементы внутри столбиком */
           align-items: center; /* Центрируем элементы */
      }
       #username-form h3, #profile-modal h3, #call-modal h3, #call-window h3 {
           margin-top: 0;
           margin-bottom: 20px;
           color: #6a1b9a; /* Темно-фиолетовый */
           font-size: 20px;
       }
        #username-form p {
           margin-bottom: 15px;
           color: #555;
        }

       /* Поля ввода в модалках */
       #username, #avatar, #new-username, #new-avatar {
          padding: 12px 15px;
          border: 1px solid #ce93d8;
          border-radius: 8px;
          width: calc(100% - 32px); /* Полная ширина минус паддинги */
          margin-bottom: 15px;
          box-sizing: border-box;
          font-size: 15px;
       }
       /* Стили для file input label */
       label.file-input-label {
           display: inline-block;
           padding: 10px 15px;
           background-color: #f3e5f5;
           color: #7b1fa2;
           border: 1px dashed #ce93d8;
           border-radius: 8px;
           cursor: pointer;
           margin-bottom: 15px;
           transition: background-color 0.2s ease;
       }
       label.file-input-label:hover {
           background-color: #e1bee7;
       }
       /* Превью аватара */
       img.avatar-preview {
           max-width: 100px;
           max-height: 100px;
           border-radius: 50%;
           margin-bottom: 15px;
           display: none; /* Скрыто пока нет файла */
           border: 2px solid #ce93d8;
           padding: 3px;
           background-color: white;
       }

       /* Кнопки в модалках */
       #save-btn, #save-profile-btn, #accept-call-btn, #reject-call-btn, #end-call-btn, .modal-cancel-btn {
          background-color: #ab47bc; /* Основной фиолетовый */
          color: white;
          border: none;
          padding: 12px 25px; /* Крупнее кнопки */
          border-radius: 8px;
          cursor: pointer;
          margin: 10px 5px 0;
          font-size: 15px;
          font-weight: 500;
          transition: background-color 0.2s ease, box-shadow 0.2s ease;
           box-shadow: 0 2px 4px rgba(0,0,0,0.1);
       }
       #save-btn:hover, #save-profile-btn:hover, #accept-call-btn:hover, #reject-call-btn:hover, #end-call-btn:hover, .modal-cancel-btn:hover {
          background-color: #8e24aa; /* Темнее при наведении */
           box-shadow: 0 3px 6px rgba(0,0,0,0.15);
       }
        /* Специфичные цвета кнопок звонка */
        #accept-call-btn { background-color: #4caf50; } /* Зеленый */
        #accept-call-btn:hover { background-color: #388e3c; }
        #reject-call-btn, #end-call-btn { background-color: #f44336; } /* Красный */
        #reject-call-btn:hover, #end-call-btn:hover { background-color: #d32f2f; }
        .modal-cancel-btn { background-color: #9e9e9e; } /* Серый для отмены */
        .modal-cancel-btn:hover { background-color: #757575; }


      /* --- Чат --- */
      #chat {
          flex-grow: 1; /* Занимает доступное место */
          height: 450px; /* Фиксированная высота для скролла */
          overflow-y: auto;
          padding: 20px;
          background: #f3e5f5; /* Светло-фиолетовый фон чата */
          border-bottom: 1px solid #e1bee7; /* Разделитель */
          /* Скругление только верхних углов, если input-area внизу */
           border-top-left-radius: 18px;
           border-top-right-radius: 18px;
           display: flex;
           flex-direction: column; /* Сообщения идут столбиком */
      }
       #chat:empty::before { /* Плейсхолдер для пустого чата */
           content: "Пока нет сообщений...";
           display: block;
           text-align: center;
           color: #7b1fa2;
           padding: 50px 0;
           font-style: italic;
       }

      /* Сообщения */
      .message {
          margin-bottom: 12px; /* Отступ между сообщениями */
          padding: 10px 15px;
          border-radius: 18px; /* Более скругленные сообщения */
          max-width: 78%; /* Макс ширина сообщения */
          word-wrap: break-word;
          display: flex; /* Используем flex для аватара и контента */
          align-items: flex-start; /* Аватар и текст сверху */
          line-height: 1.45; /* Улучшенная читаемость */
          position: relative; /* Для кнопки удаления */
      }
      .my-message {
          background-color: #ab47bc; /* Фиолетовый для своих */
          color: white;
          margin-left: auto; /* Справа */
          border-bottom-right-radius: 5px; /* Другой угол для визуального отличия */
           flex-direction: row-reverse; /* Аватар справа */
      }
      .other-message {
          background-color: #e1bee7; /* Светло-фиолетовый для чужих */
          color: #333; /* Темный текст */
          margin-right: auto; /* Слева */
          border-bottom-left-radius: 5px;
           flex-direction: row; /* Аватар слева */
      }
      .avatar {
          width: 35px; /* Крупнее аватар */
          height: 35px;
          border-radius: 50%;
          border: 1px solid rgba(0, 0, 0, 0.1);
          margin: 0 10px; /* Отступы вокруг аватара */
          flex-shrink: 0; /* Не сжимать аватар */
      }
      .my-message .avatar { margin-left: 10px; margin-right: 0; } /* Отступ слева для своего аватара */
      .other-message .avatar { margin-right: 10px; margin-left: 0; }

       .message-content-wrapper {
           display: flex;
           flex-direction: column; /* Имя и текст/картинка столбиком */
           flex-grow: 1; /* Занимать доступное место */
       }
      .username {
          font-weight: 600;
          font-size: 13px; /* Меньше имя пользователя */
          margin-bottom: 3px; /* Отступ под именем */
          color: rgba(0, 0, 0, 0.6); /* Темно-серый цвет имени */
      }
       /* Имя пользователя в своих сообщениях */
      .my-message .username {
           color: rgba(255, 255, 255, 0.8); /* Светлое имя */
           text-align: right; /* Выравнивание по правому краю для своих сообщений */
      }
       .message-text {
          font-size: 15px; /* Размер основного текста */
       }
      .message img.content-img {
          max-width: 100%;
          max-height: 300px;
          object-fit: cover;
          border-radius: 10px;
          margin-top: 8px;
          cursor: pointer;
           border: 1px solid rgba(0,0,0,0.1);
      }
       /* Кнопка удаления */
      .delete-btn {
          background: none;
          border: none;
          color: rgba(255, 255, 255, 0.6); /* Белый полупрозрачный для своих */
          font-weight: normal;
          position: absolute; /* Позиционируем относительно сообщения */
          top: 5px;
          right: 8px;
          cursor: pointer;
          display: none; /* Скрыта по умолчанию */
          font-size: 16px;
          padding: 2px;
          line-height: 1;
           opacity: 0.7;
           transition: opacity 0.2s ease;
      }
       /* Показываем кнопку при наведении на свое сообщение */
      .my-message:hover .delete-btn {
          display: block;
      }
       .delete-btn:hover {
           opacity: 1.0;
           color: #ffcdd2; /* Светло-красный при наведении */
       }
       /* Для чужих сообщений кнопка не нужна */
       .other-message .delete-btn { display: none !important; }


      /* --- Область ввода --- */
      #input-area {
          display: flex;
          padding: 15px 20px;
          border-top: 1px solid #ce93d8;
          align-items: center;
          background: rgba(255, 255, 255, 0.95);
           /* Скругление только нижних углов */
           border-bottom-left-radius: 18px;
           border-bottom-right-radius: 18px;
      }
      #message {
          flex: 1;
          padding: 12px 18px;
          border: 1px solid #ce93d8;
          border-radius: 25px; /* Сильно скругленное поле ввода */
          outline: none;
          font-size: 15px;
          background: #fff;
          margin-right: 10px;
           resize: none; /* Запретить изменение размера */
           min-height: 20px; /* Минимальная высота для одной строки */
           max-height: 100px; /* Максимальная высота для нескольких строк */
           overflow-y: auto; /* Добавить скролл, если текста много */
      }
      #input-area button {
          background: none;
          border: none;
          color: #7b1fa2; /* Фиолетовый для иконок */
          font-size: 24px; /* Крупнее иконки */
          margin-left: 8px;
          cursor: pointer;
          padding: 5px;
          transition: color 0.2s ease, transform 0.1s ease;
           line-height: 1; /* Убрать лишнюю высоту строки */
      }
      #input-area button:hover {
          color: #4a148c; /* Темнее при наведении */
      }
       #input-area button:active {
           transform: scale(0.9); /* Эффект нажатия */
       }
       #send-btn {
           font-weight: bold;
       }
       /* Превью картинки для отправки */
      #message-preview-container {
           padding: 0 20px 10px;
           text-align: left; /* Выравнивание влево */
           display: none; /* Скрыто по умолчанию */
           background: rgba(255, 255, 255, 0.95); /* Тот же фон, что и у input-area */
      }
       #message-preview {
           max-width: 80px;
           max-height: 80px;
           border-radius: 5px;
           margin-top: 5px;
           border: 1px solid #eee;
           vertical-align: middle; /* Выравнивание по центру строки */
       }
       #message-preview-container button { /* Кнопка отмены превью */
           font-size: 16px; /* Размер крестика */
           background: none;
           border: none;
           color: #aaa;
           cursor: pointer;
           padding: 0 5px;
           margin-left: 5px;
           vertical-align: middle;
       }
        #message-preview-container button:hover {
           color: #f44336; /* Красный при наведении */
        }

      /* --- Выбор эмодзи --- */
      #emoji-picker {
          display: none;
          position: absolute;
          bottom: 75px; /* Выше поля ввода */
          right: 20px;
          background: white;
          border: 1px solid #ce93d8;
          padding: 15px;
          border-radius: 10px;
          box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
          z-index: 1001; /* Выше остальных элементов */
           width: auto; /* Авто ширина */
           max-width: 300px; /* Макс ширина */
      }
      .emoji {
          font-size: 26px; /* Крупнее эмодзи */
          cursor: pointer;
          margin: 4px 6px;
          display: inline-block;
          transition: transform 0.1s ease;
      }
      .emoji:hover {
          transform: scale(1.2); /* Эффект зума */
      }

      /* --- Список пользователей --- */
      #users-list {
          padding: 20px 25px;
          margin-top: 0; /* Убираем верхний отступ, если чат виден */
           /* Скругление только нижних углов, если он под чатом */
           border-top-left-radius: 0;
           border-top-right-radius: 0;
           border-top: 1px solid #e1bee7; /* Разделитель */
           background: rgba(255, 255, 255, 0.9); /* Чуть прозрачнее */
            border-bottom-left-radius: 18px; /* Скругляем и низ */
            border-bottom-right-radius: 18px;
      }
      #users-list h3 {
          margin-top: 0;
          margin-bottom: 15px;
          color: #6a1b9a;
          border-bottom: 1px solid #e1bee7;
          padding-bottom: 10px;
          font-size: 18px; /* Размер заголовка списка */
      }
       #users-content:empty::before { /* Плейсхолдер для пустого списка */
           content: "Других пользователей нет онлайн";
           display: block;
           text-align: center;
           color: #7b1fa2;
           padding: 20px 0;
           font-style: italic;
       }
      .user-item {
          display: flex;
          align-items: center;
          margin-bottom: 12px;
          padding: 10px;
          border-radius: 10px;
          transition: background-color 0.2s ease;
          position: relative; /* Для кнопки звонка */
      }
      .user-item:hover {
          background-color: #f3e5f5;
      }
      .user-item img.avatar { /* Стили аватара в списке */
          width: 45px; /* Крупнее аватар в списке */
          height: 45px;
          margin-right: 15px;
           border: 2px solid transparent; /* Граница для статуса */
      }
        /* Статус пользователя */
       .user-item img.avatar.online { border-color: #4caf50; /* Зеленая граница для онлайна */}
       .user-item img.avatar.offline { border-color: #ccc; /* Серая граница для офлайна */}

       .user-item .user-info {
           flex-grow: 1;
       }
       .user-item span.username-in-list { /* Имя пользователя в списке */
           font-size: 15px;
           font-weight: 500;
           color: #4a148c;
           display: block; /* Имя на своей строке */
       }
       .user-item .last-seen {
           font-size: 11px;
           color: #7b1fa2;
           display: block;
           margin-top: 2px;
       }
        .user-item .last-seen.online { color: #4caf50; font-weight: 500; } /* Зеленый статус */
        .user-item .last-seen.offline { color: #9e9e9e; } /* Серый статус */

       /* Кнопка звонка */
       .call-user-btn {
          background-color: #4caf50;
          color: white;
          padding: 8px 10px; /* Меньше паддинг */
          border-radius: 50%; /* Круглая кнопка */
          font-size: 18px; /* Размер иконки звонка */
          margin-left: 15px; /* Отступ слева */
          cursor: pointer;
          border: none;
          transition: background-color 0.2s ease, transform 0.1s ease;
           line-height: 1; /* Убрать лишнюю высоту */
           flex-shrink: 0; /* Не сжимать кнопку */
       }
       .call-user-btn:hover {
          background-color: #388e3c;
       }
        .call-user-btn:active {
           transform: scale(0.9);
       }


      /* --- Окно активного звонка --- */
      #call-window {
           background-color: #e1f5fe; /* Светло-голубой фон */
           border-color: #81d4fa;
      }
       #call-window h3 {
           color: #0277bd;
       }
       #call-participants {
           margin: 15px 0;
           font-weight: 500;
           color: #03a9f4;
           min-height: 20px; /* Резервируем место */
       }
        /* Индикатор загрузки/соединения */
       .connecting-indicator {
           display: none; /* Показываем через JS */
           margin: 10px auto;
           border: 5px solid #f3f3f3; /* Светлый фон */
           border-top: 5px solid #03a9f4; /* Синий */
           border-radius: 50%;
           width: 35px;
           height: 35px;
           animation: spin 1.2s linear infinite;
       }
        @keyframes spin {
           0% { transform: rotate(0deg); }
           100% { transform: rotate(360deg); }
       }

        /* Скрытый аудио элемент */
        #remote-audio {
           display: none;
        }

       /* --- Модальное окно для изображений --- */
       #imageModal {
           display: none;
           position: fixed;
           z-index: 2000; /* Выше всего */
           left: 0;
           top: 0;
           width: 100%;
           height: 100%;
           overflow: auto;
           background-color: rgba(0,0,0,0.85); /* Темнее фон */
           cursor: pointer; /* Указываем, что можно кликнуть для закрытия */
       }
       #modalImage {
           margin: auto;
           display: block;
           max-width: 90%;
           max-height: 85%;
           position: absolute;
           top: 50%;
           left: 50%;
           transform: translate(-50%, -50%);
            border-radius: 5px;
            cursor: default; /* Обычный курсор на самом изображении */
       }
       #imageModal .close-modal-btn { /* Кнопка закрытия */
           position: absolute;
           top: 15px;
           right: 30px;
           color: #f1f1f1;
           font-size: 45px;
           font-weight: bold;
           cursor: pointer;
           transition: color 0.2s ease;
           line-height: 1;
       }
       #imageModal .close-modal-btn:hover {
           color: #bbb;
       }
    </style>
  </head>
  <body>
    <h1>Huiber <button id="profile-btn">👤 Профиль</button></h1>

    <div id="username-form" style="display: none;">
      <h3>Добро пожаловать!</h3>
      <p>Представьтесь и выберите аватар:</p>
      <input type="text" id="username" placeholder="Ваше имя" required />
      <br />
      <label for="avatar" class="file-input-label">📷 Выбрать аватар</label>
      <input
        type="file"
        id="avatar"
        accept="image/*"
        style="display: none;"
        required
      />
      <br />
      <img
        id="avatar-preview"
        src="#"
        alt="Предпросмотр аватара"
        class="avatar-preview"
      />
      <br />
      <button id="save-btn" onclick="setUsername()">Войти в чат</button>
    </div>

    <div id="profile-modal" style="display: none;">
      <h3>Редактировать профиль</h3>
      <input type="text" id="new-username" placeholder="Новое имя" />
      <br />
      <label for="new-avatar" class="file-input-label">📷 Сменить аватар</label>
      <input
        type="file"
        id="new-avatar"
        accept="image/*"
        style="display: none;"
      />
      <br />
      <img
        id="new-avatar-preview"
        src="#"
        alt="Предпросмотр нового аватара"
        class="avatar-preview"
      />
      <br />
      <button id="save-profile-btn" onclick="updateProfile()">Сохранить</button>
      <button
        class="modal-cancel-btn"
        onclick="document.getElementById('profile-modal').style.display = 'none'"
      >
        Отмена
      </button>
    </div>

    <div id="call-modal" style="display: none;">
      <h3 id="call-text">Входящий звонок...</h3>
      <p style="font-size: 40px;">📞</p>
      <button id="accept-call-btn" onclick="acceptCall()">Принять</button>
      <button id="reject-call-btn" onclick="rejectCall()">Отклонить</button>
    </div>

    <div id="call-window" style="display: none;">
      <h3>🔊 Аудиозвонок</h3>
      <div class="connecting-indicator" id="connecting-indicator"></div>
      <p id="call-participants">Соединение...</p>
      <audio
        id="remote-audio"
        autoplay
        playsinline
        style="display: none;"
      ></audio>
      <button id="end-call-btn" onclick="endCall()">Завершить</button>
    </div>

    <div id="chat-container" style="display: none;">
      <div id="chat"></div>
      <div id="input-area">
        <input type="text" id="message" placeholder="Введите сообщение..." />
        <button id="emoji-btn" title="Эмодзи">😊</button>
        <input
          type="file"
          id="file-input"
          accept="image/*"
          style="display: none;"
          onchange="previewImage(event, 'message-preview-container')"
        />
        <button
          id="file-btn"
          onclick="document.getElementById('file-input').click()"
          title="Прикрепить фото"
        >
          📷
        </button>
        <button id="send-btn" onclick="sendMessage()" title="Отправить">
          ➤
        </button>
      </div>
      <div id="message-preview-container">
        <img id="message-preview" src="#" alt="Предпросмотр изображения" />
        <button onclick="clearMessagePreview()" title="Убрать изображение">
          ✖
        </button>
      </div>
      <div id="emoji-picker">
        <span class="emoji" onclick="addEmoji('😊')">😊</span>
        <span class="emoji" onclick="addEmoji('😂')">😂</span>
        <span class="emoji" onclick="addEmoji('❤️')">❤️</span>
        <span class="emoji" onclick="addEmoji('👍')">👍</span>
        <span class="emoji" onclick="addEmoji('😢')">😢</span>
        <span class="emoji" onclick="addEmoji('🤔')">🤔</span>
        <span class="emoji" onclick="addEmoji('🎉')">🎉</span>
        <span class="emoji" onclick="addEmoji('🔥')">🔥</span>
        <span class="emoji" onclick="addEmoji('👋')">👋</span>
        <span class="emoji" onclick="addEmoji('🙏')">🙏</span>
        <span class="emoji" onclick="addEmoji('👀')">👀</span>
        <span class="emoji" onclick="addEmoji('✨')">✨</span>
        <span class="emoji" onclick="addEmoji('ѝ')">ѝ</span>
      </div>
    </div>

    <div id="users-list" style="display: none;">
      <h3>👥 Пользователи онлайн</h3>
      <div id="users-content"></div>
    </div>

    <audio id="ringtone" src="/static/ringtone.mp3" loop></audio>

    <div id="imageModal" onclick="closeImageModal()">
      <span class="close-modal-btn" onclick="closeImageModal(event)"
        >&times;</span
      >
      <img id="modalImage" onclick="event.stopPropagation()" />
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.1/socket.io.js"></script>
    <script>
      // --- Глобальные переменные и конфигурация ---
      const socket = io(); // Автоматически подключится к серверу, откуда загружена страница
      let username = localStorage.getItem('username');
      let avatar = localStorage.getItem('avatar');
      let users = {}; // Локальный кэш данных пользователей

      // WebRTC Globals
      let peerConnection;
      let localStream;
      let currentTarget = null; // Пользователь, которому звоним или кто звонит нам
      let receivedOffer = null; // Хранение оффера при входящем звонке
      const ringtone = document.getElementById('ringtone');
      const remoteAudio = document.getElementById('remote-audio');

      // ICE Server Configuration (STUN)
      const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'stun:stun3.l.google.com:19302' },
            { urls: 'stun:stun4.l.google.com:19302' },
             // Если проблемы сохраняются, рассмотрите добавление TURN сервера
             // { urls: 'turn:your.turn.server:port', username: 'user', credential: 'password' }
        ]
      };

      // --- Инициализация при загрузке страницы ---
      document.addEventListener('DOMContentLoaded', () => {
          if (!username || !avatar) {
              showLogin();
          } else {
              showChat();
              initializeChat();
          }
      });

      function showLogin() {
          hideElement('chat-container');
          hideElement('users-list');
          showElement('username-form');
          // Настройка превью для формы входа
          document.getElementById('avatar').onchange = (event) => {
              previewImage(event, 'avatar-preview'); // Используем ID превью
          };
      }

       function showChat() {
           hideElement('username-form');
           showElement('chat-container');
           showElement('users-list'); // Показываем список пользователей вместе с чатом
           document.getElementById('users-list').style.marginTop = '0'; // Убираем отступ у списка
       }

       // Хелперы для скрытия/показа элементов
       function showElement(id) {
           const el = document.getElementById(id);
           if (el) el.style.display = 'flex'; // Используем flex для основных контейнеров
            // Для модальных окон используем block или flex в зависимости от стилей
           if (['username-form', 'profile-modal', 'call-modal', 'call-window', 'imageModal'].includes(id)) {
                el.style.display = 'flex'; // Модалки тоже flex
           }
       }
       function hideElement(id) {
           const el = document.getElementById(id);
           if (el) el.style.display = 'none';
       }


      function initializeChat() {
          console.log("Initializing chat for user:", username);
          updateMessageStyles(); // Применяем стили к статическим сообщениям (если они есть)
          socket.connect(); // Убедимся, что сокет подключен
          socket.emit('user_active', { username: username, avatar: avatar });
          socket.emit('get_users');
          socket.emit('get_messages'); // Запрашиваем историю сообщений
          requestNotificationPermission();
          setupGlobalListeners(); // Настраиваем глобальные обработчики сокета
          // Устанавливаем периодический пинг активности
          startActivityPing();
      }

       let activityPingInterval;
       function startActivityPing() {
           clearInterval(activityPingInterval); // Очищаем предыдущий интервал, если есть
           activityPingInterval = setInterval(() => {
               if (socket.connected && username) {
                   // console.log("Sending periodic user_active ping");
                   socket.emit('user_active', { username: username, avatar: avatar });
               }
           }, 30000); // Пинг каждые 30 секунд
       }


      // --- Управление пользователем (Вход, Профиль) ---
      function setUsername() {
          const usernameInput = document.getElementById('username');
          const avatarInput = document.getElementById('avatar');
          const potentialUsername = usernameInput.value.trim();
          const avatarFile = avatarInput.files[0];

          if (potentialUsername && avatarFile) {
              // Проверка имени пользователя (простой пример)
               if (potentialUsername.length < 3 || potentialUsername.length > 15) {
                    alert("Имя пользователя должно быть от 3 до 15 символов.");
                    return;
               }
               if (!/^[a-zA-Z0-9а-яА-ЯёЁ_-]+$/.test(potentialUsername)) {
                    alert("Имя пользователя может содержать только буквы, цифры, _ и -.");
                    return;
               }


              const formData = new FormData();
              formData.append('file', avatarFile);

              // Индикация загрузки (опционально)
              const saveBtn = document.getElementById('save-btn');
              saveBtn.textContent = 'Загрузка...';
              saveBtn.disabled = true;

              fetch('/upload', { method: 'POST', body: formData })
                  .then(response => {
                      if (!response.ok) throw new Error(`Upload failed: ${response.status} ${response.statusText}`);
                      return response.text();
                  })
                  .then(filename => {
                       username = potentialUsername; // Устанавливаем глобальное имя
                       avatar = filename;
                       localStorage.setItem('username', username);
                       localStorage.setItem('avatar', avatar);
                       showChat();
                       initializeChat();
                  })
                  .catch(error => {
                      console.error('Error setting username/avatar:', error);
                      alert(`Ошибка загрузки аватара: ${error.message}. Попробуйте снова.`);
                  })
                  .finally(() => {
                       // Возвращаем кнопку в исходное состояние
                       saveBtn.textContent = 'Войти в чат';
                       saveBtn.disabled = false;
                  });
          } else {
              alert('Пожалуйста, введите имя и выберите аватар.');
          }
      }

      function updateProfile() {
         // ... (код функции updateProfile остается таким же, как в предыдущем ответе) ...
          const newUsernameInput = document.getElementById('new-username');
          const newAvatarInput = document.getElementById('new-avatar');
          const newUsername = newUsernameInput.value.trim();
          const newAvatarFile = newAvatarInput.files[0];

          let updateData = {};
          let needsReload = false;
          const oldUsername = localStorage.getItem('username');

           // Валидация нового имени, если оно введено
           if (newUsername && newUsername !== oldUsername) {
                if (newUsername.length < 3 || newUsername.length > 15) {
                    alert("Новое имя пользователя должно быть от 3 до 15 символов.");
                    return;
                }
                if (!/^[a-zA-Z0-9а-яА-ЯёЁ_-]+$/.test(newUsername)) {
                    alert("Новое имя пользователя может содержать только буквы, цифры, _ и -.");
                    return;
                }
                 updateData.username = newUsername;
                 needsReload = true; // Имя изменилось - нужна перезагрузка
           }

          const handleUpdate = (updatedAvatarFilename = null) => {
              if (updateData.username) {
                  localStorage.setItem('username', updateData.username);
                  username = updateData.username; // Обновляем глобальную переменную
              }
              if (updatedAvatarFilename) {
                  updateData.avatar = updatedAvatarFilename;
                  localStorage.setItem('avatar', updatedAvatarFilename);
                  avatar = updatedAvatarFilename; // Обновляем глобальную переменную
              }

              if (Object.keys(updateData).length > 0) {
                    console.log("Updating profile on server:", { username: username, avatar: avatar });
                    socket.emit('user_active', { username: username, avatar: avatar }); // Отправляем обновленные данные
                    // Обновление списка пользователей инициируется сервером после user_active
                    alert('Профиль обновлен!');
                    hideElement('profile-modal');
                    document.getElementById('new-username').value = ''; // Очищаем поля
                    document.getElementById('new-avatar').value = '';
                    document.getElementById('new-avatar-preview').style.display = 'none';
                    document.getElementById('new-avatar-preview').src = '#';

                    if (needsReload) {
                        console.log("Username changed, reloading page...");
                        location.reload(); // Перезагружаем страницу для полного обновления
                    } else {
                         // Если изменился только аватар, обновляем стили без перезагрузки
                         updateMessageStyles();
                         updateUsersList(); // Обновляем список, чтобы показать новый аватар
                    }
                } else {
                    hideElement('profile-modal'); // Просто закрываем, если нет изменений
                }
          };

          // Индикация загрузки (опционально)
          const saveProfileBtn = document.getElementById('save-profile-btn');


          if (newAvatarFile) {
               saveProfileBtn.textContent = 'Загрузка...';
               saveProfileBtn.disabled = true;
              const formData = new FormData();
              formData.append('file', newAvatarFile);
              fetch('/upload', { method: 'POST', body: formData })
                  .then(response => {
                       if (!response.ok) throw new Error(`Upload failed: ${response.status} ${response.statusText}`);
                       return response.text();
                   })
                  .then(filename => handleUpdate(filename))
                  .catch(error => {
                      console.error('Error updating profile avatar:', error);
                      alert(`Ошибка загрузки нового аватара: ${error.message}.`);
                  })
                  .finally(() => {
                       saveProfileBtn.textContent = 'Сохранить';
                       saveProfileBtn.disabled = false;
                  });
          } else {
              handleUpdate(); // Обновляем только имя, если нужно
          }
      }


      // --- Управление сообщениями ---

      function replaceDenis(text) {
           return text.replace(/\b(денис|denis)\b/gi, 'ХУЕСОС');
      }

      function renderMessage(msg, prepend = false) {
          const chat = document.getElementById('chat');
          if (!chat) return; // Выходим, если чат не найден

          // Проверяем, существует ли сообщение с таким ID уже в чате
          if (document.querySelector(`.message[data-id="${msg.id}"]`)) {
              console.warn(`Message with ID ${msg.id} already exists. Skipping render.`);
              return;
          }

          const isScrolledToBottom = chat.scrollHeight - chat.clientHeight <= chat.scrollTop + 100; // Более мягкое условие

          const div = document.createElement('div');
          div.className = 'message';
          div.dataset.id = msg.id;
          div.dataset.username = msg.username;

          // Получаем аватар из кэша users или используем дефолтный
          const userAvatarFilename = users[msg.username]?.avatar || null;
          const avatarSrc = userAvatarFilename ? `/static/uploads/${userAvatarFilename}` : '/static/logo.png'; // Используем logo.png как дефолтный
          const defaultAvatarOnError = '/static/logo.png'; // Путь к дефолтному аватару на случай ошибки загрузки

          const messageText = replaceDenis(msg.text || ""); // Заменяем Дениса

          let imageHTML = '';
          if (msg.image) {
              const imageSrc = `/static/uploads/${msg.image}`;
              // Добавлена проверка alt для доступности
              imageHTML = `<img src="${imageSrc}" class="content-img" onclick="openImageModal('${imageSrc}')" alt="Изображение от ${msg.username || 'пользователя'}">`;
          }

          let deleteButtonHTML = '';
          // Кнопка удаления только для своих сообщений
          if (msg.username === username) {
              deleteButtonHTML = `<button class="delete-btn" onclick="deleteMessage('${msg.id}')" title="Удалить">🗑️</button>`;
          }

          div.innerHTML = `
              <img src="${avatarSrc}" class="avatar" alt="${msg.username}'s avatar" onerror="this.onerror=null;this.src='${defaultAvatarOnError}';">
              <div class="message-content-wrapper">
                   <span class="username">${msg.username || 'Аноним'}:</span>
                   <span class="message-text">${messageText}</span>
                   ${imageHTML}
              </div>
              ${deleteButtonHTML}
          `;

           if (prepend) {
               chat.insertBefore(div, chat.firstChild); // Добавляем в начало для истории
           } else {
               chat.appendChild(div); // Добавляем в конец для новых сообщений
           }

          updateSingleMessageStyle(div); // Применяем стиль к конкретному сообщению

           // Авто-скролл только если добавляем новое сообщение и были внизу
           if (!prepend && isScrolledToBottom) {
              chat.scrollTop = chat.scrollHeight;
           }
      }

      function sendMessage() {
          const input = document.getElementById('message');
          const fileInput = document.getElementById('file-input');
          const text = input.value.trim();
          const file = fileInput.files[0];

          if ((text || file) && username) {
              const sendMessageData = (imageData = null) => {
                  console.log(`Sending message: Text='${text}', Image='${imageData}'`);
                  socket.emit('send_message', {
                      message: text,
                      username: username,
                      image: imageData
                  });
                  input.value = ''; // Очищаем поле ввода
                  fileInput.value = ''; // Очищаем поле файла
                  clearMessagePreview(); // Очищаем превью
              };

              if (file) {
                   // Индикация загрузки файла (опционально)
                   const sendBtn = document.getElementById('send-btn');
                   sendBtn.disabled = true; // Блокируем кнопку на время загрузки

                  const formData = new FormData();
                  formData.append('file', file);
                  fetch('/upload', { method: 'POST', body: formData })
                      .then(response => {
                           if (!response.ok) throw new Error(`Upload failed: ${response.status} ${response.statusText}`);
                           return response.text();
                       })
                      .then(filename => sendMessageData(filename))
                      .catch(error => {
                          console.error('Error uploading image:', error);
                          alert(`Ошибка загрузки изображения: ${error.message}.`);
                          clearMessagePreview(); // Очищаем превью при ошибке
                      })
                      .finally(() => {
                           sendBtn.disabled = false; // Разблокируем кнопку
                      });
              } else {
                  sendMessageData(); // Отправляем текстовое сообщение
              }
          }
      }

       function deleteMessage(id) {
         if (confirm('Вы уверены, что хотите удалить это сообщение?')) {
            console.log(`Requesting deletion of message ID: ${id} by user: ${username}`);
            socket.emit('delete_message', { id: id, username: username });
         }
       }


      // --- Обновление UI и Хелперы ---

      function updateMessageStyles() {
          const messages = document.querySelectorAll('.message');
          messages.forEach(msg => updateSingleMessageStyle(msg));
          // Скролл вниз после полного обновления (например, при загрузке истории)
          const chat = document.getElementById('chat');
          if(chat) chat.scrollTop = chat.scrollHeight;
      }

      function updateSingleMessageStyle(msgElement) {
            if (!msgElement || !msgElement.dataset) return;
            const msgUsername = msgElement.dataset.username;
            const isMy = msgUsername === username;
            msgElement.classList.toggle('my-message', isMy);
            msgElement.classList.toggle('other-message', !isMy);

            const deleteBtn = msgElement.querySelector('.delete-btn');
            if(deleteBtn){
                deleteBtn.style.display = isMy ? '' : 'none'; // Показываем/скрываем кнопку удаления
            }
             // Обновляем видимость аватара (на всякий случай, если стили изменились)
             const avatarImg = msgElement.querySelector('.avatar');
             if (avatarImg) {
                 const userAvatarFilename = users[msgUsername]?.avatar || null;
                 avatarImg.src = userAvatarFilename ? `/static/uploads/${userAvatarFilename}` : '/static/logo.png';
             }
      }

      function updateUsersList() {
          console.log("Updating users list display with data:", users);
          const usersContent = document.getElementById('users-content');
           if (!usersContent) return;
          usersContent.innerHTML = ''; // Очищаем список

          const now = new Date();
          const onlineThreshold = 60 * 1000; // 1 минута для статуса "онлайн"

          let hasOtherUsers = false;
          Object.entries(users).forEach(([user, info]) => {
              if (user === username) return; // Не показываем себя в списке
              hasOtherUsers = true;

              const div = document.createElement('div');
              div.className = 'user-item';
              div.id = `user-${user}`; // Добавляем ID для возможного обновления

              const avatarFilename = info.avatar || null;
              const avatarSrc = avatarFilename ? `/static/uploads/${avatarFilename}` : '/static/logo.png';
              const defaultAvatarOnError = '/static/logo.png';

              let statusText = 'Офлайн';
              let statusClass = 'offline';

              if (info.last_seen) {
                    try {
                       const lastSeenDate = new Date(info.last_seen);
                       const timeDiff = now.getTime() - lastSeenDate.getTime();

                       if (!isNaN(timeDiff) && timeDiff < onlineThreshold) {
                           statusText = 'Онлайн';
                           statusClass = 'online';
                       } else if (!isNaN(lastSeenDate.getTime())) {
                           // Форматируем дату/время последнего визита
                           statusText = `Был(а) ${lastSeenDate.toLocaleString('ru-RU', { dateStyle: 'short', timeStyle: 'short' })}`;
                       } else {
                            statusText = "Статус неизвестен"; // Если дата невалидна
                       }
                    } catch (e) {
                        console.error("Error parsing date for user", user, info.last_seen, e);
                        statusText = "Статус неизвестен";
                    }
              } else {
                    statusText = "Статус неизвестен"; // Если нет last_seen
              }

              // Кнопка звонка только если пользователь онлайн
              const callButtonHTML = statusClass === 'online'
                  ? `<button class="call-user-btn" onclick="callUser('${user}')" title="Позвонить ${user}">📞</button>`
                  : '';

              div.innerHTML = `
                  <img src="${avatarSrc}" class="avatar ${statusClass}" alt="${user}'s avatar" onerror="this.onerror=null;this.src='${defaultAvatarOnError}';">
                  <div class="user-info">
                      <span class="username-in-list">${user}</span>
                      <span class="last-seen ${statusClass}">${statusText}</span>
                  </div>
                  ${callButtonHTML}
              `;

              usersContent.appendChild(div);
          });

           // Показываем сообщение, если других пользователей нет
           if (!hasOtherUsers) {
                usersContent.innerHTML = '<p style="text-align: center; color: #7b1fa2; padding: 20px 0; font-style: italic;">Других пользователей нет онлайн</p>';
           }
      }

      function addEmoji(emoji) {
          const messageInput = document.getElementById('message');
          messageInput.value += emoji;
          hideElement('emoji-picker');
          messageInput.focus();
      }

      // Превью изображения перед отправкой/сменой аватара
      function previewImage(event, previewElementId) {
          const previewElement = document.getElementById(previewElementId);
           if (!previewElement) return;
          const input = event.target;
          const file = input.files ? input.files[0] : null;

          if (file && file.type.startsWith('image/')) {
              const reader = new FileReader();
              reader.onload = (e) => {
                  previewElement.src = e.target.result;
                  previewElement.style.display = 'block'; // Показываем превью
                   // Показываем контейнер для превью сообщения (если это он)
                   if (previewElementId === 'message-preview') {
                        showElement('message-preview-container');
                   }
              }
              reader.readAsDataURL(file);
          } else {
               // Сбрасываем, если файл не выбран или не картинка
              previewElement.src = '#';
              previewElement.style.display = 'none';
               if (previewElementId === 'message-preview') {
                    hideElement('message-preview-container');
               }
               // Очищаем input type="file", если пользователь отменил выбор
               input.value = '';
          }
      }


       // Очистка превью сообщения
       function clearMessagePreview() {
          const previewContainer = document.getElementById('message-preview-container');
          const previewImage = document.getElementById('message-preview');
          const fileInput = document.getElementById('file-input');
           if(previewImage) previewImage.src = '#';
           if(previewContainer) previewContainer.style.display = 'none';
           if(fileInput) fileInput.value = ''; // Важно очистить поле файла
       }

        // Настройка превью для смены аватара в профиле
        document.getElementById('new-avatar').onchange = (event) => previewImage(event, 'new-avatar-preview');


      function requestNotificationPermission() {
         // ... (код функции requestNotificationPermission остается таким же) ...
          if (!('Notification' in window)) {
            console.log('Уведомления не поддерживаются в этом браузере');
            return;
          }
          if (Notification.permission === 'default') {
              Notification.requestPermission().then(permission => {
                  if (permission === 'granted') {
                      console.log('Разрешение на уведомления получено');
                      new Notification('Huiber Уведомления', {
                          body: 'Уведомления включены!',
                          icon: '/static/logo.png',
                          tag: 'huiber-permission' // Тэг, чтобы не дублировать
                      });
                  } else {
                      console.log('Разрешение на уведомления отклонено');
                  }
              }).catch(err => {
                  console.error('Ошибка запроса разрешения:', err);
              });
          }
      }

       function showNotification(title, body, icon) {
           // ... (код функции showNotification остается таким же) ...
            if ('Notification' in window && Notification.permission === 'granted' && document.hidden) {
                 // Используем tag, чтобы уведомления заменяли друг друга, а не накапливались
                 const notification = new Notification(title, { body: body, icon: icon || '/static/logo.png', tag: 'huiber-message' });
                  // Можно добавить автозакрытие
                  setTimeout(notification.close.bind(notification), 7000); // Закрыть через 7 секунд
            }
       }

        // --- Функции Модального Окна Изображения ---
       function openImageModal(src) {
           const modal = document.getElementById('imageModal');
           const modalImg = document.getElementById('modalImage');
            if (modal && modalImg) {
               modalImg.src = src;
               showElement('imageModal'); // Используем flex для показа
            }
       }

       function closeImageModal(event) {
            // Проверяем, был ли клик непосредственно на фоне (а не на картинке)
            // или на кнопке закрытия
            if (!event || event.target.id === 'imageModal' || event.target.classList.contains('close-modal-btn')) {
               const modal = document.getElementById('imageModal');
               const modalImg = document.getElementById('modalImage');
                if (modal && modalImg) {
                   hideElement('imageModal');
                   modalImg.src = ''; // Очищаем src для экономии памяти
                }
                 // Предотвращаем всплытие, если клик был на кнопке
                 if (event) event.stopPropagation();
            }
       }


      // --- Логика WebRTC Звонков (с улучшенным логированием) ---

      function createPeerConnection() {
          try {
               // Закрываем существующее соединение, если оно есть
               if (peerConnection) {
                   console.warn("Closing existing peer connection before creating a new one.");
                   cleanUpCall(); // Используем общую функцию очистки
               }

              console.log("[Peer] Creating PeerConnection with config:", configuration);
              peerConnection = new RTCPeerConnection(configuration);

              // --- Обработчики событий PeerConnection ---

              // Кандидаты ICE
              peerConnection.onicecandidate = event => {
                  if (event.candidate && currentTarget && username) { // Доп. проверка username
                      console.log(`[Peer] Sending ICE candidate for ${currentTarget}:`, event.candidate.type, event.candidate.sdpMLineIndex);
                      socket.emit('ice_candidate', {
                          target: currentTarget,
                          candidate: event.candidate,
                          sender: username
                      });
                  } else if (!event.candidate) {
                      console.log("[Peer] All ICE candidates gathered.");
                  } else {
                       console.warn("[Peer] Not sending ICE candidate (no target/username or empty candidate).");
                  }
              };

              // Входящий медиа-трек
              peerConnection.ontrack = event => {
                  console.log("[Peer] Track received:", event.track.kind, "Stream:", event.streams[0]?.id);
                  const remoteAudio = document.getElementById('remote-audio');
                  if (remoteAudio && event.streams && event.streams[0]) {
                      console.log("[Peer] Attaching remote stream to audio element.");
                       // Важно: Не устанавливать srcObject повторно, если он уже есть
                       if (remoteAudio.srcObject !== event.streams[0]) {
                           remoteAudio.srcObject = event.streams[0];
                       } else {
                           console.log("[Peer] Remote stream already attached.");
                       }

                       // Попытка воспроизведения
                       console.log("[Peer] Attempting to play remote audio...");
                       remoteAudio.play().then(() => {
                           console.log("[Peer] Remote audio playback started successfully.");
                           // Обновляем UI только при успехе
                           document.getElementById('call-participants').textContent = `В разговоре с: ${currentTarget || '???'}`;
                           document.getElementById('connecting-indicator').style.display = 'none';
                       }).catch(e => {
                           console.error("[Peer] ERROR playing remote audio:", e);
                           document.getElementById('call-participants').textContent = `Разговор с ${currentTarget || '???'} (проблема со звуком)`;
                           document.getElementById('connecting-indicator').style.display = 'none';
                           // Можно показать кнопку "Play" пользователю
                       });
                  } else {
                      console.error("[Peer] Failed to attach track: No remoteAudio element or stream available.");
                  }
              };

              // Состояние ICE соединения
              peerConnection.oniceconnectionstatechange = () => {
                   if (!peerConnection) return; // Защита от срабатывания после закрытия
                   console.log(`[Peer] >> ICE Connection State Changed: ${peerConnection.iceConnectionState}`);
                   const indicator = document.getElementById('connecting-indicator');
                   const participantsText = document.getElementById('call-participants');
                   const targetName = currentTarget || "собеседник";

                   switch(peerConnection.iceConnectionState) {
                       case "new":
                       case "checking":
                           if (indicator) indicator.style.display = 'block';
                           if (participantsText) participantsText.textContent = `Соединение с ${targetName}...`;
                           break;
                       case "connected": // Базовое соединение есть, ждем медиа
                            if (indicator) indicator.style.display = 'none';
                            console.log("[Peer] ICE connected. Waiting for media stream via 'ontrack'.");
                            // Текст обновится в ontrack при получении медиа
                           break;
                       case "completed": // Обмен кандидатами завершен
                            if (indicator) indicator.style.display = 'none';
                            console.log("[Peer] ICE negotiation completed.");
                            break;
                       case "disconnected": // Может восстановиться
                            if (indicator) indicator.style.display = 'none';
                            if (participantsText) participantsText.textContent = `Соединение с ${targetName} прервано...`;
                            console.warn("[Peer] ICE disconnected.");
                            break;
                       case "failed": // Не удалось подключиться
                            if (indicator) indicator.style.display = 'none';
                            if (participantsText) participantsText.textContent = `Не удалось соединиться с ${targetName}`;
                            console.error("[Peer] ICE connection failed.");
                            alert(`Не удалось установить соединение с ${targetName}. Проверьте консоль.`);
                            endCall();
                            break;
                       case "closed": // Соединение закрыто
                            if (indicator) indicator.style.display = 'none';
                            if (participantsText) participantsText.textContent = `Звонок с ${targetName} завершен`;
                            console.log("[Peer] ICE connection closed.");
                            // Убедимся, что очистка прошла
                            cleanUpCall();
                            break;
                       default:
                            if (indicator) indicator.style.display = 'none';
                           break;
                   }
              };

               // Состояние сигнализации (offer/answer)
               peerConnection.onsignalingstatechange = () => {
                   if (!peerConnection) return;
                   console.log(`[Peer] >> Signaling State Changed: ${peerConnection.signalingState}`);
               };

              return peerConnection;

          } catch (error) {
              console.error("[Peer] FATAL Error creating PeerConnection:", error);
              alert("Критическая ошибка при инициализации звонка. Обновите страницу или проверьте браузер.");
              return null;
          }
      }

       async function startLocalMedia() {
           console.log("[Media] Requesting user media (audio only)...");
           try {
               localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
               console.log("[Media] Local media stream obtained successfully:", localStream.id);
               return localStream;
           } catch (error) {
               console.error("[Media] ERROR getting user media:", error.name, error.message);
               if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                   alert("Доступ к микрофону запрещен. Пожалуйста, разрешите доступ в настройках браузера.");
               } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                   alert("Микрофон не найден. Убедитесь, что он подключен и работает.");
               } else {
                    alert(`Не удалось получить доступ к микрофону: ${error.message}`);
               }
               return null;
           }
       }


      async function callUser(targetUsername) {
           console.log(`[CallFlow] Attempting callUser(${targetUsername}) by ${username}`);
          if (!username) return alert("Сначала войдите в систему.");
          if (currentTarget) return alert("Вы уже участвуете в звонке или звоните.");

          currentTarget = targetUsername;

          localStream = await startLocalMedia();
          if (!localStream) { currentTarget = null; return; } // Выход, если микрофон не доступен

          peerConnection = createPeerConnection();
          if (!peerConnection) { cleanUpCall(); return; } // Выход, если PC не создан

           // Добавляем локальные треки
           console.log("[CallFlow:Caller] Adding local tracks...");
           localStream.getTracks().forEach(track => {
              try {
                  peerConnection.addTrack(track, localStream);
                  console.log(`[CallFlow:Caller] Local track added: ${track.kind} (${track.id})`);
              } catch (e) {
                  console.error("[CallFlow:Caller] ERROR adding track:", e);
              }
           });

           // Показываем UI звонка для инициатора
           document.getElementById('call-participants').textContent = `Звонок пользователю ${currentTarget}...`;
           document.getElementById('connecting-indicator').style.display = 'block';
           showElement('call-window');

          try {
                console.log(`[CallFlow:Caller] Creating offer for ${currentTarget}`);
                const offer = await peerConnection.createOffer();
                console.log(`[CallFlow:Caller] Offer created. Setting local description.`);

                 // Установка локального описания
                 try {
                     await peerConnection.setLocalDescription(offer);
                     console.log(`[CallFlow:Caller] Local description (offer) set. Emitting offer to server.`);
                     // Отправка оффера через сервер
                     socket.emit('offer', {
                         offer: peerConnection.localDescription, // Отправляем полное описание
                         target: currentTarget,
                         caller: username
                     });
                 } catch (e) {
                      console.error(`[CallFlow:Caller] ERROR setting local description (offer):`, e);
                      alert(`Ошибка установки локального описания: ${e.message}`);
                      endCall();
                 }
          } catch (error) {
                console.error("[CallFlow:Caller] ERROR creating offer:", error);
                alert(`Не удалось создать предложение для звонка: ${error.message}`);
                endCall();
          }
      }

      async function acceptCall() {
          console.log(`[CallFlow:Callee] Attempting acceptCall() from ${currentTarget} by ${username}`);
          if (!currentTarget || !receivedOffer) {
              console.error("[CallFlow:Callee] Cannot accept call: Missing target or received offer.");
              rejectCall(); // Отклоняем, если нет нужных данных
              return;
          }

           hideElement('call-modal');
           ringtone.pause();
           ringtone.currentTime = 0;

          localStream = await startLocalMedia();
          if (!localStream) { rejectCall(); return; } // Отклоняем, если нет микрофона

          peerConnection = createPeerConnection();
          if (!peerConnection) { rejectCall(); return; } // Отклоняем, если не создался PC


           // Показываем UI звонка для принимающего
           document.getElementById('call-participants').textContent = `Соединение с ${currentTarget}...`;
           document.getElementById('connecting-indicator').style.display = 'block';
           showElement('call-window');


           // Добавляем локальные треки ПЕРЕД установкой remote description
           console.log("[CallFlow:Callee] Adding local tracks...");
           localStream.getTracks().forEach(track => {
               try {
                   peerConnection.addTrack(track, localStream);
                   console.log(`[CallFlow:Callee] Local track added: ${track.kind} (${track.id})`);
               } catch (e) {
                   console.error("[CallFlow:Callee] ERROR adding track:", e);
               }
           });

          try {
              console.log(`[CallFlow:Callee] Setting remote description (offer) from ${currentTarget}`);
              await peerConnection.setRemoteDescription(new RTCSessionDescription(receivedOffer)); // Используем сохраненный оффер
              console.log(`[CallFlow:Callee] Remote description (offer) set. Creating answer.`);
              receivedOffer = null; // Очищаем сохраненный оффер

              const answer = await peerConnection.createAnswer();
              console.log(`[CallFlow:Callee] Answer created. Setting local description (answer).`);

               // Установка локального описания (ответа)
               try {
                   await peerConnection.setLocalDescription(answer);
                   console.log(`[CallFlow:Callee] Local description (answer) set. Emitting answer to server for ${currentTarget}.`);
                   // Отправка ответа через сервер
                   socket.emit('answer', {
                       answer: peerConnection.localDescription, // Отправляем полное описание
                       target: currentTarget, // Кому предназначен ответ (инициатору звонка)
                       caller: username      // Кто отправляет ответ (мы)
                   });
               } catch(e) {
                   console.error(`[CallFlow:Callee] ERROR setting local description (answer):`, e);
                   alert(`Ошибка установки локального описания (ответа): ${e.message}`);
                   endCall();
               }

          } catch (error) {
              console.error("[CallFlow:Callee] ERROR processing offer or creating answer:", error);
              alert(`Не удалось обработать звонок: ${error.message}`);
              endCall();
          }
      }

      function rejectCall() {
          console.log(`[CallFlow] Rejecting call from ${currentTarget} by ${username}`);
          // Опционально: уведомить звонящего об отклонении
          // if (currentTarget) {
          //     socket.emit('call_rejected', { target: currentTarget, caller: username });
          // }
          cleanUpCall(); // Используем общую очистку
          hideElement('call-modal'); // Убедимся, что модалка скрыта
      }

      function endCall() {
          console.log(`[CallFlow] Ending call with ${currentTarget} initiated by ${username}`);
          // Опционально: уведомить другого участника о завершении
          // if (currentTarget) {
          //     socket.emit('call_ended', { target: currentTarget, sender: username });
          // }
          cleanUpCall(); // Вызываем общую функцию очистки
      }


      function cleanUpCall() {
           console.log("[Cleanup] Starting call cleanup...");
           if (peerConnection) {
               peerConnection.onicecandidate = null;
               peerConnection.ontrack = null;
               peerConnection.oniceconnectionstatechange = null;
               peerConnection.onsignalingstatechange = null;
               // Закрываем соединение, если оно не закрыто
               if (peerConnection.signalingState !== 'closed') {
                   peerConnection.close();
                   console.log("[Cleanup] PeerConnection closed.");
               }
               peerConnection = null; // Убираем ссылку
           } else {
                console.log("[Cleanup] No active peer connection found.");
           }

           if (localStream) {
               console.log("[Cleanup] Stopping local stream tracks...");
               localStream.getTracks().forEach(track => track.stop());
               localStream = null;
           } else {
                console.log("[Cleanup] No active local stream found.");
           }

           const remoteAudio = document.getElementById('remote-audio');
            if (remoteAudio && remoteAudio.srcObject) {
               console.log("[Cleanup] Stopping remote stream tracks and clearing srcObject...");
               // remoteAudio.srcObject.getTracks().forEach(track => track.stop()); // Браузер должен делать это сам при srcObject = null
               remoteAudio.srcObject = null;
               remoteAudio.pause();
               remoteAudio.removeAttribute('src'); // На всякий случай
               remoteAudio.load(); // Сброс состояния элемента
            } else {
                 console.log("[Cleanup] No active remote stream found on audio element.");
            }

           // Сброс UI
           hideElement('call-window');
           hideElement('call-modal');
           const indicator = document.getElementById('connecting-indicator');
           const participantsText = document.getElementById('call-participants');
           if(indicator) indicator.style.display = 'none';
           if(participantsText) participantsText.textContent = 'Соединение...';

           // Остановка рингтона
           ringtone.pause();
           ringtone.currentTime = 0;

           // Сброс переменных состояния звонка
           console.log(`[Cleanup] Resetting call state (currentTarget was: ${currentTarget})`);
           currentTarget = null;
           receivedOffer = null;
           console.log("[Cleanup] Call cleanup finished.");
      }

      // --- Глобальные обработчики событий Socket.IO ---
      function setupGlobalListeners() {
          console.log("[Socket] Setting up global Socket.IO listeners.");

           // Убираем предыдущие обработчики, чтобы избежать дублирования при переподключении
           socket.off('connect');
           socket.off('disconnect');
           socket.off('reconnect');
           socket.off('connect_error');
           socket.off('initial_messages');
           socket.off('new_message');
           socket.off('message_deleted');
           socket.off('users_list');
           socket.off('update_users');
           socket.off('incoming_call');
           socket.off('offer');
           socket.off('answer');
           socket.off('ice_candidate');
           // socket.off('call_ended_by_peer'); // Если будете добавлять

            socket.on('connect', () => {
                console.log(`[Socket] Connected successfully with SID: ${socket.id}`);
                // При подключении (или переподключении) снова регистрируем пользователя
                if (username && avatar) {
                     console.log("[Socket] Re-emitting user_active and getting data on connect.");
                     socket.emit('user_active', { username: username, avatar: avatar });
                     socket.emit('get_users');
                     socket.emit('get_messages');
                }
            });

            socket.on('disconnect', (reason) => {
               console.warn(`[Socket] Disconnected: ${reason}`);
               // Очищаем состояние звонка при дисконнекте
               if (currentTarget) {
                    console.warn("[Socket] Cleaning up call state due to disconnection.");
                    cleanUpCall();
                    alert("Соединение потеряно. Звонок завершен.");
               }
                // Можно показать индикатор потери соединения
            });

            socket.on('reconnect', (attemptNumber) => {
                console.log(`[Socket] Reconnected after ${attemptNumber} attempts.`);
                // User_active и get_data будут отправлены обработчиком 'connect'
            });

            socket.on('connect_error', (err) => {
             console.error("[Socket] Connection error:", err.message);
             // Очищаем состояние звонка при ошибке подключения
              if (currentTarget) {
                  console.warn("[Socket] Cleaning up call state due to connection error.");
                  cleanUpCall();
              }
             alert("Не удается подключиться к серверу чата. Проверьте соединение.");
           });


            // Загрузка истории сообщений
           socket.on('initial_messages', function(loadedMessages) {
                console.log(`[Socket] Received initial_messages (${loadedMessages.messages?.length || 0} messages)`);
                const chat = document.getElementById('chat');
                if (!chat) return;
                chat.innerHTML = ''; // Очищаем чат перед загрузкой истории

                if (loadedMessages.users) {
                     console.log("[Socket] Updating users cache from initial_messages");
                     users = loadedMessages.users; // Обновляем кэш пользователей
                }

                if (loadedMessages.messages && loadedMessages.messages.length > 0) {
                    loadedMessages.messages.forEach(msg => renderMessage(msg)); // Отображаем каждое сообщение
                } else {
                     // Можно показать сообщение "Нет сообщений"
                     chat.innerHTML = '<p style="text-align: center; color: #7b1fa2; padding: 50px 0; font-style: italic;">Пока нет сообщений...</p>';
                }
                updateMessageStyles(); // Применяем стили и скроллим вниз
            });

          socket.on('new_message', function(msg) {
             console.log(`[Socket] Received new_message from ${msg.username} (ID: ${msg.id})`);
             // Обновляем кэш пользователя, если инфо пришло с сообщением
              if (msg.username && msg.avatar && (!users[msg.username] || users[msg.username].avatar !== msg.avatar)) {
                  console.log(`[Socket] Updating user cache for ${msg.username} from new_message`);
                  users[msg.username] = { ...(users[msg.username] || {}), avatar: msg.avatar, last_seen: new Date().toISOString() };
              }
             renderMessage(msg); // Добавляем в конец чата
             // Показываем уведомление, если нужно
             if (msg.username !== username) {
                 const avatarSrc = users[msg.username]?.avatar ? `/static/uploads/${users[msg.username].avatar}` : '/static/logo.png';
                 showNotification(
                     `Новое сообщение от ${msg.username}`,
                     replaceDenis(msg.text || (msg.image ? "[Изображение]" : "")),
                     avatarSrc
                 );
             }
          });

          socket.on('message_deleted', function(data) {
             console.log(`[Socket] Received message_deleted for ID: ${data.id}`);
             const msgElement = document.querySelector(`.message[data-id="${data.id}"]`);
             if (msgElement) {
                 msgElement.remove();
                 console.log(`[UI] Message element ${data.id} removed.`);
             } else {
                  console.warn(`[UI] Could not find message element ${data.id} to delete.`);
             }
          });

          // Обновление списка пользователей (полное или частичное)
          socket.on('users_list', function(users_data) {
             console.log("[Socket] Received users_list update.");
             users = users_data || {}; // Обновляем локальный кэш
             updateUsersList();
             updateMessageStyles(); // Обновляем стили сообщений (на случай смены аватара)
          });
           // Для обратной совместимости, если сервер шлет 'update_users'
           socket.on('update_users', function(users_data) {
               console.log("[Socket] Received 'update_users' (legacy?) update.");
               users = users_data || {};
               updateUsersList();
               updateMessageStyles();
           });


          // --- Обработчики сигнализации WebRTC ---

          socket.on('incoming_call', function(data) {
             console.log(`[Socket] Received incoming_call from: ${data.caller}`);
             if (currentTarget) {
                 console.warn(`[Socket] Ignoring incoming call from ${data.caller} because already in call with ${currentTarget}.`);
                 // Опционально: Уведомить звонящего, что вы заняты
                 // socket.emit('user_busy', { target: data.caller, caller: username });
                 return;
             }
              // Ждем 'offer' событие отдельно
              currentTarget = data.caller;
              document.getElementById('call-text').textContent = `Входящий звонок от ${currentTarget}`;
              showElement('call-modal');
              ringtone.play().catch(e => console.warn("Ringtone play failed:", e));
          });


          socket.on('offer', async function(data) {
               console.log(`[Socket:${username}] Received 'offer' event from ${data.sender}`);
               // Обрабатываем только если это ожидаемый звонящий и мы не в звонке/не звоним сами
               // (currentTarget устанавливается в incoming_call)
               if (data.sender === currentTarget) {
                   if (peerConnection && peerConnection.signalingState !== 'stable') {
                        console.warn(`[Socket:${username}] Received offer while P.C. is not stable (${peerConnection.signalingState}). Ignoring.`);
                        return; // Не обрабатываем новый оффер, если уже идет установка соединения
                   }
                   console.log(`[Socket:${username}] Storing received offer from ${data.sender}.`);
                   receivedOffer = data.offer; // Сохраняем для acceptCall
                   // Не создаем PeerConnection здесь, ждем нажатия Accept
               } else {
                    console.warn(`[Socket:${username}] Ignoring offer from unexpected sender: ${data.sender}. Expecting: ${currentTarget}`);
               }
          });


          socket.on('answer', async function(data) {
               console.log(`[Socket:${username}] Received 'answer' event from ${data.sender}`);
               // Проверяем, что есть активное соединение и ответ от ожидаемого пользователя
               if (peerConnection && data.sender === currentTarget) {
                   if (peerConnection.signalingState === 'have-local-offer') {
                       console.log(`[Socket:${username}] Setting remote description (answer) from ${currentTarget}`);
                       try {
                           await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                           console.log(`[Socket:${username}] Remote description (answer) set successfully.`);
                       } catch (error) {
                           console.error(`[Socket:${username}] ERROR setting remote description (answer):`, error);
                           alert(`Ошибка применения ответа от ${currentTarget}: ${error.message}`);
                           endCall();
                       }
                   } else {
                        console.warn(`[Socket:${username}] Received answer in unexpected signaling state: ${peerConnection.signalingState}. Ignoring.`);
                   }
               } else {
                   console.warn(`[Socket:${username}] Ignoring answer: PC?(${!!peerConnection}) Sender?(${data.sender} vs ${currentTarget})`);
               }
          });


          socket.on('ice_candidate', async function(data) {
               // console.log(`[Socket:${username}] Received 'ice_candidate' event from ${data.sender}`); // Очень много логов, можно закомментировать
               // Добавляем кандидата только если есть соединение, оно не закрыто, и кандидат от ожидаемого пира
               if (peerConnection && peerConnection.signalingState !== 'closed' && data.sender === currentTarget && data.candidate) {
                    try {
                       // console.log(`[Socket:${username}] Adding received ICE candidate from ${currentTarget}`); // Тоже много логов
                       await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                       // console.log(`[Socket:${username}] ICE candidate added successfully.`);
                   } catch (error) {
                       // Игнорируем ошибки добавления кандидатов если соединение уже закрывается/закрыто
                       if (peerConnection && peerConnection.signalingState !== 'closed') {
                          console.warn(`[Socket:${username}] Error adding received ICE candidate:`, error.message);
                       }
                   }
               } else {
                   // Логируем игнорирование только если есть текущая цель звонка
                   // if (currentTarget) {
                   //     console.warn(`[Socket:${username}] Ignoring ICE candidate: PC?(${!!peerConnection}) Closed?(${peerConnection?.signalingState === 'closed'}) Sender?(${data.sender} vs ${currentTarget}) Cand?(${!!data.candidate})`);
                   // }
               }
          });

          // --- Опциональные обработчики завершения/отклонения звонка другим пиром ---
          // Вам нужно будет добавить соответствующие emit на сервере и здесь
          // socket.on('call_ended_by_peer', function(data) {
          //     if (data.sender === currentTarget) {
          //         console.log(`[Socket] Call ended by peer: ${data.sender}`);
          //         alert(`Звонок с ${data.sender} завершен другим пользователем.`);
          //         cleanUpCall();
          //     }
          // });
          // socket.on('call_rejected_by_peer', function(data) {
          //     if (data.sender === currentTarget) {
          //         console.log(`[Socket] Call rejected by peer: ${data.sender}`);
          //         alert(`${data.sender} отклонил(а) ваш звонок.`);
          //         cleanUpCall();
          //     }
          // });
          // socket.on('peer_is_busy', function(data) {
          //     if (data.sender === currentTarget) {
          //         console.log(`[Socket] Peer is busy: ${data.sender}`);
          //         alert(`${data.sender} сейчас занят(а).`);
          //         cleanUpCall();
          //     }
          // });

      } // --- Конец setupGlobalListeners ---


      // --- Обработчики событий UI ---
      document.getElementById('message').addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
      });

      document.getElementById('profile-btn').addEventListener('click', function() {
         document.getElementById('new-username').value = username || ''; // Предзаполняем имя
         const currentAvatarPreview = document.getElementById('new-avatar-preview');
         if (avatar) { // Показываем текущий аватар
            currentAvatarPreview.src = `/static/uploads/${avatar}`;
            currentAvatarPreview.style.display = 'block';
         } else {
            currentAvatarPreview.style.display = 'none';
            currentAvatarPreview.src = '#';
         }
         showElement('profile-modal');
      });

      document.getElementById('emoji-btn').addEventListener('click', function(event) {
         event.stopPropagation();
         const picker = document.getElementById('emoji-picker');
         picker.style.display = picker.style.display === 'block' ? 'none' : 'block';
      });

      // Закрытие пикера эмодзи по клику вне его
      document.addEventListener('click', function(event) {
         const picker = document.getElementById('emoji-picker');
         const emojiBtn = document.getElementById('emoji-btn');
          // Проверяем, что пикер видим, и клик был не по нему и не по кнопке его вызова
         if (picker && picker.style.display === 'block' && !picker.contains(event.target) && event.target !== emojiBtn) {
           hideElement('emoji-picker');
         }
       });

       // --- Инициализация скролла чата при загрузке (если нужно) ---
       window.onload = () => {
         const chat = document.getElementById('chat');
         if(chat) chat.scrollTop = chat.scrollHeight;
       };
    </script>
  </body>
</html>
